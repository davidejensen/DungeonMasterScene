"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEqual = exports.areConnected = exports.inBounds = exports.getObject = exports.parse = exports.getBounds = void 0;
/**
 * Returns metaverse coordinates bounds.
 * TODO: use functions from @dcl/schemas
 */
function getBounds() {
    return {
        minX: -150,
        minY: -150,
        maxX: 165,
        maxY: 165
    };
}
exports.getBounds = getBounds;
/**
 * Parses a string-based set of coordinates.
 * - All spaces are removed
 * - Leading zeroes are removed
 * - `-0` is converted to `0`
 * @param coordinates An string containing coordinates in the `x,y; x,y; ...` format
 */
function parse(coordinates) {
    return coordinates.split(';').map((coord) => {
        const [x, y] = coord.split(',').map(($) => {
            return parseInt($, 10)
                .toString() // removes spaces :)
                .replace('-0', '0')
                .replace(/undefined|NaN/g, '0');
        });
        return `${x},${y}`;
    });
}
exports.parse = parse;
/**
 * Converts a string-based set of coordinates to an object
 * @param coords A string containing a set of coordinates
 */
function getObject(coords) {
    const [x, y] = parse(coords)[0].split(',');
    return { x: parseInt(x.toString(), 10), y: parseInt(y.toString(), 10) };
}
exports.getObject = getObject;
/**
 * Returns true if the given coordinates are in metaverse bounds
 */
function inBounds(x, y) {
    const { minX, minY, maxX, maxY } = getBounds();
    return x >= minX && x <= maxX && y >= minY && y <= maxY;
}
exports.inBounds = inBounds;
/**
 * Returns true if the given parcels array are connected
 */
function areConnected(parcels) {
    if (parcels.length === 0) {
        return false;
    }
    const visited = visitParcel(parcels[0], parcels);
    return visited.length === parcels.length;
}
exports.areConnected = areConnected;
function visitParcel(parcel, allParcels, visited = []) {
    const isVisited = visited.some((visitedParcel) => isEqual(visitedParcel, parcel));
    if (!isVisited) {
        visited.push(parcel);
        const neighbours = getNeighbours(parcel.x, parcel.y, allParcels);
        neighbours.forEach((neighbours) => visitParcel(neighbours, allParcels, visited));
    }
    return visited;
}
function getIsNeighbourMatcher(x, y) {
    return (coords) => (coords.x === x && (coords.y + 1 === y || coords.y - 1 === y)) ||
        (coords.y === y && (coords.x + 1 === x || coords.x - 1 === x));
}
function getNeighbours(x, y, parcels) {
    return parcels.filter(getIsNeighbourMatcher(x, y));
}
function isEqual(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
exports.isEqual = isEqual;
//# sourceMappingURL=coordinates.js.map