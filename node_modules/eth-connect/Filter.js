/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
import * as utils from './utils/utils';
import * as formatters from './utils/formatters';
import * as config from './utils/config';
import { future } from 'fp-future';
import { stringToUtf8Bytes } from './utils/utf8';
function safeAsync(fn) {
    return function () {
        // tslint:disable-next-line:no-console
        fn().catch(($) => console.error($));
    };
}
/**
 * Converts a given topic to a hex string, but also allows null values.
 *
 * @param value - The given value
 */
function toTopic(value) {
    if (value === null || typeof value === 'undefined')
        return null;
    const strValue = String(value).toString();
    if (strValue.indexOf('0x') === 0) {
        return strValue;
    }
    else {
        return utils.bytesToHex(stringToUtf8Bytes(strValue));
    }
}
export class AbstractFilter {
    constructor(requestManager) {
        this.requestManager = requestManager;
        this.isStarted = false;
        this.isDisposed = false;
        this.formatter = x => x;
        this.filterId = future();
        this.callbacks = [];
        this.stopSemaphore = future();
        // stub
    }
    async watch(callback) {
        if (this.isDisposed)
            throw new Error('The filter was disposed');
        if (callback) {
            this.callbacks.push(callback);
            if (!this.isStarted) {
                await this.start();
            }
        }
    }
    async start() {
        if (this.isDisposed)
            throw new Error('The filter was disposed');
        if (this.isStarted)
            return;
        this.isStarted = true;
        try {
            const id = await this.getNewFilter();
            if (!id) {
                throw new Error('Could not create a filter, response: ' + JSON.stringify(id));
            }
            this.filterId.resolve(id);
        }
        catch (e) {
            throw e;
        }
        this.stopSemaphore = future();
        await this.poll();
    }
    async stop() {
        if (!this.isStarted)
            return;
        if (this.isDisposed)
            return;
        this.isDisposed = true;
        const filterId = await this.filterId;
        this.isStarted = false;
        if (this.stopSemaphore)
            await this.stopSemaphore;
        const didStop = await this.uninstall();
        if (didStop !== true) {
            throw new Error(`Couldn't stop the eth filter: ${filterId}`);
        }
    }
    /**
     * Adds the callback and sets up the methods, to iterate over the results.
     */
    async poll() {
        if (this.isStarted) {
            if (this.callbacks.length) {
                const result = await this.getChanges();
                if (result) {
                    this.callbacks.forEach((cb) => {
                        if (this.formatter) {
                            result.forEach(($) => {
                                cb(this.formatter($));
                            });
                        }
                        else {
                            result.forEach(($) => cb($));
                        }
                    });
                }
            }
            this.stopSemaphore.resolve(1);
            if (this.isStarted) {
                this.stopSemaphore = future();
                setTimeout(safeAsync(() => this.poll()), config.ETH_POLLING_TIMEOUT);
            }
        }
        else {
            this.stopSemaphore.resolve(1);
        }
    }
}
export class SHHFilter extends AbstractFilter {
    constructor(requestManager, options) {
        super(requestManager);
        this.requestManager = requestManager;
        this.options = options;
        this.options = this.options || { topics: [] };
        this.options.topics = this.options.topics || [];
        this.options.topics = this.options.topics.map(function (topic) {
            return toTopic(topic);
        });
        this.options = {
            topics: this.options.topics,
            to: this.options.to
        };
    }
    async getMessages() {
        const filterId = await this.filterId;
        return this.requestManager.shh_getMessages(filterId);
    }
    async getNewFilter() {
        return this.requestManager.shh_newFilter(this.options);
    }
    async getChanges() {
        const filterId = await this.filterId;
        return this.requestManager.shh_getFilterChanges(filterId);
    }
    async uninstall() {
        const filterId = await this.filterId;
        return this.requestManager.shh_uninstallFilter(filterId);
    }
}
export class EthFilter extends AbstractFilter {
    constructor(requestManager, options, formatter = (x) => x) {
        super(requestManager);
        this.requestManager = requestManager;
        this.options = options;
        this.formatter = formatter;
        this.options = this.options || {};
        this.options.topics = this.options.topics || [];
        this.options.topics = this.options.topics.map(function (topic) {
            return toTopic(topic);
        });
        this.options = {
            topics: this.options.topics,
            address: this.options.address ? this.options.address : undefined,
            fromBlock: typeof this.options.fromBlock === 'number' || typeof this.options.fromBlock === 'string'
                ? formatters.inputBlockNumberFormatter(this.options.fromBlock) || undefined
                : 'latest',
            toBlock: typeof this.options.toBlock === 'number' || typeof this.options.toBlock === 'string'
                ? formatters.inputBlockNumberFormatter(this.options.toBlock) || undefined
                : 'latest'
        };
    }
    async getLogs() {
        if (!this.isStarted) {
            await this.start();
        }
        const filterId = await this.filterId;
        return this.requestManager.eth_getFilterLogs(filterId);
    }
    async getNewFilter() {
        return this.requestManager.eth_newFilter(this.options);
    }
    async getChanges() {
        const filterId = await this.filterId;
        return this.requestManager.eth_getFilterChanges(filterId);
    }
    async uninstall() {
        const filterId = await this.filterId;
        return this.requestManager.eth_uninstallFilter(filterId);
    }
}
export class EthPendingTransactionFilter extends EthFilter {
    constructor(requestManager) {
        super(requestManager, {});
    }
    async getNewFilter() {
        return this.requestManager.eth_newPendingTransactionFilter();
    }
}
export class EthBlockFilter extends EthFilter {
    constructor(requestManager) {
        super(requestManager, {});
    }
    async getNewFilter() {
        return this.requestManager.eth_newBlockFilter();
    }
}
//# sourceMappingURL=Filter.js.map