/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
// tslint:disable:variable-name
import { toJsonRpcRequest, isValidResponse } from './utils/jsonrpc';
import { InvalidProvider, InvalidResponse } from './utils/errors';
import { future } from 'fp-future';
import { eth } from './methods/eth';
import { TransactionType, TransactionStatus } from './Schema';
import { sleep } from './utils/sleep';
import { inputTransactionId } from './utils/formatters';
export let TRANSACTION_FETCH_DELAY = 2 * 1000;
export function inject(target, propertyKey) {
    const method = eth[propertyKey];
    /* istanbul ignore if */
    if (!method) {
        throw new Error(`Could not find the method/property named ${propertyKey.toString()}`);
    }
    Object.defineProperty(target, propertyKey, {
        value: function () {
            return method.execute(this, ...arguments);
        }
    });
}
/**
 * @public
 * It's responsible for passing messages to providers
 * It's also responsible for polling the ethereum node for incoming messages
 * Default poll timeout is 1 second
 */
export class RequestManager {
    constructor(provider) {
        this.provider = provider;
        // @internal
        this.requests = new Map();
        // stub
    }
    /**
     * Should be used to asynchronously send request
     *
     * @param data - The RPC message to be sent
     */
    async sendAsync(data) {
        const provider = await this.provider;
        /* istanbul ignore if */
        if (!provider) {
            throw InvalidProvider();
        }
        let payload = toJsonRpcRequest(data.method, data.params);
        const defer = future();
        this.requests.set(payload.id, defer);
        provider.sendAsync(payload, (err, result) => {
            this.requests.delete(payload.id);
            if (err) {
                defer.reject(err);
                return;
            }
            /* istanbul ignore if */
            if (!isValidResponse(result)) {
                defer.reject(InvalidResponse(result));
                return;
            }
            defer.resolve(result.result);
        });
        return defer;
    }
    /**
     * Should be used to set provider of request manager
     *
     * @param p - The provider
     */
    setProvider(p) {
        this.provider = p;
    }
    /**
     * Waits until the transaction finishes. Returns if it was successfull.
     * Throws if the transaction fails or if it lacks any of the supplied events
     * @param txId - Transaction id to watch
     */
    async getConfirmedTransaction(txId) {
        const tx = await this.waitForCompletion(txId);
        if (this.isFailure(tx)) {
            throw new Error(`Transaction "${txId}" failed`);
        }
        return tx;
    }
    /**
     * Wait until a transaction finishes by either being mined or failing
     * @param txId - Transaction id to watch
     * @param retriesOnEmpty - Number of retries when a transaction status returns empty
     */
    async waitForCompletion(txId, retriesOnEmpty) {
        const txIdString = inputTransactionId(txId);
        const isDropped = await this.isTxDropped(txIdString, retriesOnEmpty);
        if (isDropped) {
            const tx = await this.getTransactionAndReceipt(txIdString);
            return Object.assign(Object.assign({}, tx), { status: TransactionStatus.failed });
        }
        while (true) {
            const tx = await this.getTransactionAndReceipt(txIdString);
            if (!this.isPending(tx) && tx.receipt) {
                return Object.assign(Object.assign({}, tx), { status: this.isFailure(tx) ? TransactionStatus.failed : TransactionStatus.confirmed });
            }
            await sleep(TRANSACTION_FETCH_DELAY);
        }
    }
    /**
     * Returns a transaction in any of the possible states.
     * @param txId - The transaction ID
     */
    async getTransaction(txId) {
        let currentNonce = null;
        let status;
        const hash = inputTransactionId(txId);
        try {
            const accounts = await this.eth_accounts();
            const account = accounts[0];
            if (account) {
                currentNonce = await this.eth_getTransactionCount(account, 'latest');
            }
        }
        catch (error) {
            currentNonce = null;
        }
        try {
            status = await this.eth_getTransactionByHash(hash);
            // not found
            if (status == null) {
                return null;
            }
        }
        catch (e) {
            return null;
        }
        if (status.blockNumber == null) {
            if (currentNonce != null) {
                // replaced
                if (status.nonce < currentNonce) {
                    const tx = {
                        hash,
                        type: TransactionType.replaced,
                        nonce: status.nonce
                    };
                    return tx;
                }
                // queued
                if (status.nonce > currentNonce) {
                    const tx = {
                        hash,
                        type: TransactionType.queued,
                        nonce: status.nonce
                    };
                    return tx;
                }
            }
            // pending
            const tx = Object.assign({ type: TransactionType.pending }, status);
            return tx;
        }
        let receipt;
        try {
            receipt = await this.eth_getTransactionReceipt(hash);
            // reverted
            if (receipt == null || receipt.status === 0x0) {
                const tx = Object.assign({ type: TransactionType.reverted }, status);
                return tx;
            }
        }
        catch (e) {
            // TODO: should this be null or reverted?
            return null;
        }
        // confirmed
        const tx = Object.assign(Object.assign({ type: TransactionType.confirmed }, status), { receipt });
        return tx;
    }
    /**
     * Wait retryAttemps * TRANSACTION_FETCH_DELAY for a transaction status to be in the mempool
     * @param txId - Transaction id to watch
     * @param retryAttemps - Number of retries when a transaction status returns empty
     */
    async isTxDropped(txId, _retryAttemps = 15) {
        let retryAttemps = _retryAttemps;
        while (retryAttemps > 0) {
            const tx = await this.getTransactionAndReceipt(txId);
            if (tx !== null) {
                return false;
            }
            retryAttemps -= 1;
            await sleep(TRANSACTION_FETCH_DELAY);
        }
        return true;
    }
    /**
     * Get the transaction status and receipt
     * @param txId - Transaction id
     */
    // prettier-ignore
    async getTransactionAndReceipt(txId) {
        txId = inputTransactionId(txId);
        const [tx, receipt] = await Promise.all([
            this.eth_getTransactionByHash(txId),
            this.eth_getTransactionReceipt(txId)
        ]);
        return Object.assign(Object.assign({}, tx), { receipt });
    }
    /**
     * Expects the result of getTransaction's geth command and returns true if the transaction is still pending.
     * It'll also check for a pending status prop against TRANSACTION_STATUS
     * @param tx - The transaction object
     */
    // tslint:disable-next-line:prefer-function-over-method
    isPending(tx) {
        return tx && tx.blockNumber === null;
    }
    /**
     * Expects the result of getTransactionRecepeit's geth command and returns true if the transaction failed.
     * It'll also check for a failed status prop against TRANSACTION_STATUS
     * @param tx - The transaction object
     */
    // tslint:disable-next-line:prefer-function-over-method
    isFailure(tx) {
        return tx && (!tx.receipt || tx.receipt.status === 0);
    }
}
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "web3_clientVersion", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "web3_sha3", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "net_version", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "net_peerCount", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "net_listening", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_protocolVersion", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_syncing", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_coinbase", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_mining", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_hashrate", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_gasPrice", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_accounts", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_blockNumber", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getBalance", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getStorageAt", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getTransactionCount", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getBlockTransactionCountByHash", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getBlockTransactionCountByNumber", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getUncleCountByBlockHash", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getUncleCountByBlockNumber", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getCode", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_sign", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_sendTransaction", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_sendRawTransaction", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_call", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_estimateGas", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getBlockByHash", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getBlockByNumber", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getTransactionByHash", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getTransactionByBlockHashAndIndex", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getTransactionByBlockNumberAndIndex", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getTransactionReceipt", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getUncleByBlockHashAndIndex", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getUncleByBlockNumberAndIndex", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_newFilter", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_newBlockFilter", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_newPendingTransactionFilter", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_uninstallFilter", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getFilterChanges", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getFilterLogs", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getLogs", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_getWork", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_submitWork", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "eth_submitHashrate", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_post", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_version", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_newIdentity", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_hasIdentity", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_newGroup", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_addToGroup", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_newFilter", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_uninstallFilter", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_getFilterChanges", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "shh_getMessages", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "personal_unlockAccount", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "personal_newAccount", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "personal_listAccounts", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "personal_lockAccount", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "personal_importRawKey", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "personal_sendTransaction", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "personal_sign", void 0);
__decorate([
    inject,
    __metadata("design:type", Function)
], RequestManager.prototype, "personal_ecRecover", void 0);
//# sourceMappingURL=RequestManager.js.map