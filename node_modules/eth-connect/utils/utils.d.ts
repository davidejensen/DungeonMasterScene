import { BigNumber } from './BigNumber';
import { AbiItem } from '../Schema';
/**
 * @public
 */
export declare function hexToBytes(hex: string): Uint8Array;
/**
 * @public
 */
export declare function bytesToHex(bytes: Uint8Array): string;
/**
 * @public
 */
export declare function sha3(value: string | number[] | ArrayBuffer | Uint8Array, options?: {
    encoding?: 'hex';
}): string;
declare let unitMap: {
    noether: string;
    wei: string;
    kwei: string;
    Kwei: string;
    babbage: string;
    femtoether: string;
    mwei: string;
    Mwei: string;
    lovelace: string;
    picoether: string;
    gwei: string;
    Gwei: string;
    shannon: string;
    nanoether: string;
    nano: string;
    szabo: string;
    microether: string;
    micro: string;
    finney: string;
    milliether: string;
    milli: string;
    ether: string;
    kether: string;
    grand: string;
    mether: string;
    gether: string;
    tether: string;
};
export declare type Unit = keyof typeof unitMap;
/**
 * @public
 * Should be called to pad string to expected length
 */
export declare function padLeft(str: string, chars: number, sign?: string): string;
/**
 * @public
 * Should be called to pad string to expected length
 */
export declare function padRight(str: string, chars: number, sign?: string): string;
/**
 * @public
 * Should be called to get ascii from it's hex representation
 */
export declare function toAscii(hex: string): string;
/**
 * @public
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 */
export declare function fromAscii(str: string, num?: number): string;
/**
 * @public
 * Should be used to create full function/event name from json abi
 */
export declare function transformToFullName(json: AbiItem): string;
export declare function concatBytes(...buffers: Uint8Array[]): Uint8Array;
/**
 * @public
 * Should be called to get display name of contract function
 */
export declare function extractDisplayName(name: string): string;
/**
 * @public
 * Should be called to get type name of contract function
 */
export declare function extractTypeName(name: string): string;
/**
 * @public
 * Converts value to it's decimal representation in string
 */
export declare function isHex(value: string): boolean;
/**
 * @public
 * Converts value to it's decimal representation in string
 */
export declare function toNullDecimal(value: BigNumber.Value): number;
/**
 * @public
 * Converts value to it's decimal representation in string
 */
export declare function toDecimal(value: BigNumber.Value): number;
/**
 * @public
 * Converts value to string
 */
export declare function toString(value: BigNumber.Value): string;
/**
 * @public
 * Converts value to it's hex  representation in string
 */
export declare function toData(val: BigNumber.Value): string;
/**
 * @public
 * Converts a UTF8 string to it's hex representation as a 0x string.
 * If the argument is already a 0xHEX prefixed string, the conversion is skipped.
 */
export declare function toStringData(val: BigNumber.Value): string;
/**
 * @public
 * Converts value to it's boolean representation (x != 0)
 */
export declare function toBoolean(value: BigNumber.Value | boolean): boolean;
/**
 * @public
 * Converts value to it's hex representation
 */
export declare function fromDecimal(value: BigNumber.Value): string;
/**
 * @public
 * Auto converts any given value into it's hex representation.
 *
 * And even stringifys objects before.
 */
export declare function toHex(val: BigNumber.Value | boolean | Uint8Array): string;
/**
 * @public
 * Returns value of unit in Wei
 */
export declare function getValueOfUnit(_unit: Unit): BigNumber;
/**
 * @public
 * Takes a number of wei and converts it to any other ether unit.
 *
 * Possible units are:
 *   SI Short   SI Full        Effigy       Other
 * - kwei       femtoether     babbage
 * - mwei       picoether      lovelace
 * - gwei       nanoether      shannon      nano
 * - --         microether     szabo        micro
 * - --         milliether     finney       milli
 * - ether      --             --
 * - kether                    --           grand
 * - mether
 * - gether
 * - tether
 *
 */
export declare function fromWei(num: BigNumber, unit: Unit): BigNumber;
export declare function fromWei(num: string | number, unit: Unit): string;
/**
 * @public
 * Takes a number of a unit and converts it to wei.
 *
 * Possible units are:
 *   SI Short   SI Full        Effigy       Other
 * - kwei       femtoether     babbage
 * - mwei       picoether      lovelace
 * - gwei       nanoether      shannon      nano
 * - --         microether     szabo        micro
 * - --         milliether     finney       milli
 * - ether      --             --
 * - kether                    --           grand
 * - mether
 * - gether
 * - tether
 */
export declare function toWei(num: number | string, unit: Unit): string | BigNumber;
/**
 * @public
 * Takes an input and transforms it into an bignumber
 */
export declare function toBigNumber(_num: BigNumber.Value): BigNumber;
/**
 * @public
 * Takes and input transforms it into bignumber and if it is negative value, into two's complement
 */
export declare function toTwosComplement(num: BigNumber.Value, bits?: number): BigNumber;
/**
 * Check if input value is negative in twos complement
 */
export declare function signedIsNegative(value: BigNumber, bits: number): boolean;
/**
 * @public
 */
export declare function getAddress(address: string): string;
/**
 * @public
 * If the bit N is 1
 */
export declare function fromTwosComplement(num: BigNumber, bits?: number): BigNumber;
/**
 * @public
 * Checks if the given string is strictly an address
 */
export declare function isStrictAddress(address: any): boolean;
/**
 * @public
 * Checks if the given string is an address
 */
export declare function isAddress(address: any): boolean;
/**
 * @public
 * Checks if the given string is a checksummed address
 */
export declare function isChecksumAddress(_address: string): boolean;
/**
 * @public
 * Makes a checksum address
 */
export declare function toChecksumAddress(_address: string): string;
/**
 * @public
 * Ensures the result will be an array
 */
export declare function toArray(value: any): any[];
/**
 * @public
 * Transforms given string to valid 20 bytes-length addres with 0x prefix
 */
export declare function toAddress(address: string): string;
/**
 * @public
 * Returns true if object is BigNumber, otherwise false
 */
export declare function isBigNumber(object: any): object is BigNumber;
/**
 * @public
 * Returns true if object is string, otherwise false
 */
export declare function isString(value: any): value is string;
/**
 * @public
 * Returns true if object is function, otherwise false
 */
export declare function isFunction(object: any): object is CallableFunction;
/**
 * @public
 * Returns true if object is Objet, otherwise false
 */
export declare function isObject<T extends object>(object: any): object is T;
/**
 * @public
 * Returns true if object is boolean, otherwise false
 */
export declare function isBoolean(object: any): object is boolean;
/**
 * @public
 * Returns true if object is array, otherwise false
 */
export declare function isArray<T extends Array<any>>(object: any): object is T;
/**
 * @public
 * Returns true if given string is valid json object
 */
export declare function isJson(str: string): boolean;
/**
 * @public
 * Returns true if given string is a valid Ethereum block header bloom.
 */
export declare function isBloom(bloom: string): boolean;
/**
 * @public
 * Returns true if given string is a valid log topic.
 */
export declare function isTopic(topic: string): boolean;
export {};
//# sourceMappingURL=utils.d.ts.map