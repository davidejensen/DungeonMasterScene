import { toRPC } from './common';
import { future } from 'fp-future';
/**
 * @public
 */
export class WebSocketProvider {
    constructor(url, options = {}) {
        this.url = url;
        this.options = options;
        this.isDisposed = false;
        // @internal
        this.responseCallbacks = new Map();
        // @internal
        this.notificationCallbacks = new Set();
        this.debug = false;
        this.lastChunk = '';
        this.connect();
    }
    dispose() {
        this.isDisposed = true;
        const connection = this.connection;
        this.timeout(new Error('Provider disposed.'));
        // tslint:disable-next-line:no-floating-promises
        connection.then(($) => $.close());
    }
    /* istanbul ignore next */
    // tslint:disable-next-line:prefer-function-over-method
    send() {
        /* istanbul ignore next */
        throw new Error('Sync requests are deprecated');
    }
    sendAsync(payload, callback) {
        const toSend = [];
        let didFinish;
        if (payload instanceof Array) {
            didFinish = Promise.all(payload.map(($) => {
                const defer = future();
                try {
                    const message = toRPC($);
                    toSend.push(message);
                    this.responseCallbacks.set(message.id, defer);
                }
                catch (e) {
                    defer.reject(e);
                }
                return defer;
            }));
        }
        else {
            const defer = future();
            try {
                const message = toRPC(payload);
                toSend.push(message);
                this.responseCallbacks.set(message.id, defer);
            }
            catch (e) {
                defer.reject(e);
            }
            didFinish = defer;
        }
        didFinish.then(($) => callback(null, $), (err) => callback(err));
        this.connection.then((ws) => {
            toSend.forEach(($) => {
                const s = JSON.stringify($);
                /* istanbul ignore if */
                // tslint:disable-next-line:no-console
                if (this.debug)
                    console.log('SEND >> ' + s);
                ws.send(s);
            });
        }, (err) => {
            callback(err);
        });
    }
    /**
     * Will parse the response and make an array out of it.
     */
    parseResponse(data) {
        let returnValues = [];
        // DE-CHUNKER
        let dechunkedData = data
            .replace(/\}[\n\r]?\{/g, '}|--|{') // }{
            .replace(/\}\][\n\r]?\[\{/g, '}]|--|[{') // }][{
            .replace(/\}[\n\r]?\[\{/g, '}|--|[{') // }[{
            .replace(/\}\][\n\r]?\{/g, '}]|--|{') // }]{
            .split('|--|');
        dechunkedData.forEach((chunk) => {
            let data = chunk;
            // prepend the last chunk
            if (this.lastChunk) {
                data = this.lastChunk + data;
            }
            let result = null;
            try {
                result = JSON.parse(data);
            }
            catch (e) {
                this.lastChunk = data;
                // start timeout to cancel all requests
                clearTimeout(this.lastChunkTimeout);
                this.lastChunkTimeout = setTimeout(() => {
                    this.timeout();
                }, 1000 * 15);
                return;
            }
            // cancel timeout and set chunk to null
            clearTimeout(this.lastChunkTimeout);
            this.lastChunk = '';
            if (result)
                returnValues.push(result);
        });
        return returnValues;
    }
    processMessage(message) {
        if ('id' in message) {
            const id = message.id;
            const defer = this.responseCallbacks.get(id);
            if (!defer) {
                // tslint:disable-next-line:no-console
                console.error('Error: Received a response for an unknown request', message);
                return;
            }
            this.responseCallbacks.delete(id);
            if ('error' in message) {
                defer.reject(Object.assign(new Error(message.error.message || message.error), message.error));
            }
            else if ('result' in message) {
                defer.resolve(message);
            }
        }
        else {
            this.notificationCallbacks.forEach(($) => $(null, message));
        }
    }
    /**
     * Timeout all requests when the end/error event is fired
     */
    timeout(error) {
        if (!this.connection || !this.connection.isPending) {
            this.connection = future();
        }
        const timeoutError = error || new Error('Connection timeout');
        this.responseCallbacks.forEach(($) => $.reject(timeoutError));
        this.responseCallbacks.clear();
        // reset all requests and callbacks
        if (!this.isDisposed) {
            setTimeout(() => this.connect(), 1000);
        }
    }
    connect() {
        if (this.connection && !this.connection.isPending) {
            // tslint:disable-next-line
            this.connection.then(($) => $.close());
        }
        if (!this.connection || !this.connection.isPending) {
            this.connection = future();
        }
        this.lastChunk = '';
        let ctor = this.options.WebSocketConstructor || (typeof WebSocket !== 'undefined' ? WebSocket : void 0);
        if (!ctor) {
            throw new Error('Please provide a WebSocketConstructor');
        }
        const connection = new ctor(this.url, this.options.protocol);
        connection.onopen = () => {
            this.connection.resolve(connection);
        };
        connection.onerror = (error) => {
            const theError = new Error('Error in web socket');
            theError.data = error;
            this.timeout(theError);
        };
        connection.onclose = (event) => {
            this.timeout(new Error(`Connection closed (${(event && event.reason) || 'Unknown reason'})`));
        };
        // LISTEN FOR CONNECTION RESPONSES
        connection.onmessage = (e) => {
            let data = typeof e.data === 'string' ? e.data : '';
            /* istanbul ignore if */
            // tslint:disable-next-line:no-console
            if (this.debug)
                console.log('RECV << ' + e.data);
            this.parseResponse(data).forEach((result) => {
                // get the id which matches the returned id
                if (result instanceof Array) {
                    result.forEach(($) => this.processMessage($));
                }
                else {
                    this.processMessage(result);
                }
            });
        };
    }
}
export default WebSocketProvider;
//# sourceMappingURL=WebSocketProvider.js.map