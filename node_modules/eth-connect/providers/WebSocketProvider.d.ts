import { Callback, RPCMessage } from './common';
import { IFuture } from 'fp-future';
export interface IWebSocket {
    /**
     * Closes the WebSocket connection, optionally using code as the the WebSocket connection close code and reason as the the WebSocket connection close reason.
     */
    close(code?: number, reason?: string): void;
    /**
     * Transmits data using the WebSocket connection. data can be a string, a Blob, an ArrayBuffer, or an ArrayBufferView.
     */
    send(data: string): void;
    onclose: ((this: this, ev: any) => any) | null;
    onerror: ((this: this, ev: any) => any) | null;
    onmessage: ((this: this, ev: any) => any) | null;
    onopen: ((this: this, ev: any) => any) | null;
}
export declare type WebSocketProviderOptions = {
    /**
     * WebSocketConstructor, used in Node.js where WebSocket is not globally available
     */
    WebSocketConstructor?: any;
    timeout?: number;
    protocol?: string;
};
/**
 * @public
 */
export declare class WebSocketProvider<T extends IWebSocket> {
    url: string;
    options: WebSocketProviderOptions;
    isDisposed: boolean;
    connection: IFuture<T>;
    debug: boolean;
    private lastChunk;
    private lastChunkTimeout;
    constructor(url: string, options?: WebSocketProviderOptions);
    dispose(): void;
    send(): void;
    sendAsync(payload: RPCMessage | RPCMessage[], callback: Callback): void;
    /**
     * Will parse the response and make an array out of it.
     */
    private parseResponse;
    private processMessage;
    /**
     * Timeout all requests when the end/error event is fired
     */
    private timeout;
    private connect;
}
export default WebSocketProvider;
//# sourceMappingURL=WebSocketProvider.d.ts.map